* 回收算法
* 回收算法 各自优缺点
* 为什么分代
* 新生代为什么要用复制算法，老年代为什么用标记清除、标记整理
* 为什么要用两个Survivor
* 为什么分代


# 垃圾回收算法（除负正）
标记清除、复制算法、标记整理

# 缺点（除碎片、负一半、正前二）
除碎片、负一半、正前二

# 为什么分代 （不同对象生命周期不同，需要的GC频率也不同，分代提高回收效率）
不同对象生命周期不同，让这些不同生命周期的对象分代存放，并各自使用合适的回收算法，可以大大提高垃圾回收的效率


不分代的话，整个堆包含新建的对象和生命周期长的对象，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长；
同时，因为每次回收都需要遍历所有存活对象，对于生命周期长的对象而言，这种遍历是没有意义的，因为可能进行了很多次遍历，但是他们依旧存在

所以分代各自存放，并使用合适回收算法

# 新生代为什么要用复制算法，老年代为什么用标记清除、标记整理

在新生代，每次垃圾收集时都有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

在老年代，对象存活率高，没有额外空间对它进行分配担保，就必须只有标记-清除和标记-整理算法来进行回收

#### 新生代：（大量死去，少量存活，只需付出少量存活对象的复制成本即可）
#### 老年代：（存活率高，没有额外空间分配担保）

# 为什么要用两个Survivor
1.减少被送到老年代的对象，16岁的才进老年代，减少Full gc
2.解决碎片化

#　只用一个Survivor会碎片
![](/assets/20160516173704870)









