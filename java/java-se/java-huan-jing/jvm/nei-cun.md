# 故障排除流程

表现  
定性  
定位  
解决

# 表现现象

cpu高、内存高、OOM、Full gc 频繁超时（应用超时 应用很慢）

##### 表现来源

* 1.提醒方式 推送模式： 监控软件超过阀值指标 推送短信或邮件提醒！！！！
* 2.人工观察 拉模式  ： 出现问题或压测时 输入命令如jstat -gcutil 观察gc情况定位问题
  > 无论是推送模式还是拉模式，都是呈现现象来源  
  > 如推送：监控Cpu高提醒短信；如手拉：top 观察到Cpu高

# cpu 高（可能内存也高）

| 定位Java进程、线程 | 如果线程是VM线程 并一直GC | 如果线程非VM线程，即查看该线程问题 |
| :--- | :--- | :--- |
|  | 1.查看GC日志情况，是不是频繁Full gc |  |
|  | 2 jmap -dump 内存情况 dump 文件 |  |
|  | 3 eclipse mat 分析dump文件没问题 |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |

* 1.先定位java进程、线程
* 2.知道是GC 回收线程,或线程在干嘛
* 3.dump文件 mat 定位对象
* 4.GC 文件分析 确定 内存、对象没问题   确定是不是软件的问题定时调用
* 5.理由bcTrance 确认谁调用system gc
* 6.确认是cxf工具包1.先定位java进程、线程

##### 定位进程、线程

* 1.通过 top 命令找到 CPU 消耗最高的进程，并记住进程 ID。
* 2.再次通过 top -Hp \[进程 ID\] 找到 CPU 消耗最高的线程 ID，并记住线程 ID.
* 3.通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：\* 4.jstack -l \[进程 ID\] &gt;jstack.log。
* 5.由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是 16 进制的，因此我们需要将 10 进制的转换成 16 进制的，并用这个线程 ID 在堆栈中查找。使用 printf "%x\n" \[十进制数字\] ，可以将 10 进制转换成 16 进制。
* 6.通过刚刚转换的 16 进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪

###### \# 如果查到是GC 线程则说明是在GC工作

就去查看GC 日志

###### \# 如果查到是其他线程原因：如线程死循环、死锁、密集运算



